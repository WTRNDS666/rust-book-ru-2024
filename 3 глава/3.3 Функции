============
Функции
============

Функции в Расте повсюду. Главную ты уже знаешь — это `main`, точка входа. Объявляются они через ключевое слово `fn`.

В Rust принято использовать snakecase** (змеиный регистр): всё маленькими буквами, слова через подчеркивание.

```rust
fn main() {
    println!("Хай, мир!");
    anotherfunction();
}

fn anotherfunction() {
    println!("Я другая функция.");
}
```
Расту пофиг, где ты объявил функцию — до `main` или после. Главное, чтобы она вообще была в зоне видимости.

### Параметры
В функции можно прокидывать данные. В Rust ты **обязан** указывать типы параметров в заголовке функции. Это сделано специально: компилятор сразу понимает, что ты хочешь, и не гадает на кофейной гуще.

```rust
fn main() {
    printvalue(5);
}

fn printvalue(x: i32) {
    println!("Значение x: {x}");
}
```

### Инструкции (Statements) и Выражения (Expressions) — ВАЖНО!
Вот тут внимательно, это главная фишка Раста.
1.  **Инструкции (Statements)** — это действия, которые **не возвращают** значения. Например, `let x = 6;`. Ты не можешь написать `let x = (let y = 6)`, Rust плюнет тебе в лицо ошибкой.
2.  **Выражения (Expressions)** — это то, что **вычисляется в значение**. `5 + 6` — это выражение (даёт 11). Вызов функции — это выражение. Даже блок в фигурных скобках — это выражение!

Смотри магию:
```rust
fn main() {
    let y = {
        let x = 3;
        x + 1  // ЗАМЕТЬ: тут нет точки с запятой!
    };
    println!("Значение y: {y}"); // Выведет 4
}
```
Если ты поставишь точку с запятой после `x + 1`, ты превратишь выражение в инструкцию, и оно перестанет возвращать значение. Это супер-важно для функций.

### Функции с возвратом значения
Чтобы функция что-то возвращала, ставим стрелочку `->` и пишем тип. В Rust не обязательно писать `return`, функция просто берет **последнее выражение** из своего тела и возвращает его.

```rust
fn five() -> i32 {
    5 // Просто 5 без точки с запятой. Это выражение, оно и вернется.
}

fn main() {
    let x = five();
    println!("x равно: {x}");
}
```

А теперь смотри, как легко всё сломать:
```rust
fn plusone(x: i32) -> i32 {
    x + 1; // ОШИБКА! Поставил точку с запятой — превратил в инструкцию.
}
```
Компилятор скажет: «Слышь, ты обещал вернуть i32, а в итоге в конце стоит инструкция, которая возвращает пустоту ()».

Золотое правило:
*   Хочешь вернуть значение из конца функции? Не ставь точку с запятой.
–   Нужно выйти раньше времени? Юзай return x;.
