========================
Типы данных в Rust
========================

В Rust у каждого значения есть свой тип. Это база, чтобы комп понимал, что перед ним — число, буква или какая-то сложная фигня. Rust — язык со статической типизацией, то есть он должен знать все типы еще на этапе компиляции. Обычно он сам догадывается (выводит тип), но когда вариантов много (как с `.parse()`), ему надо подсказать: `let x: u32 = ...`.

### Скалярные типы (Одиночки)
Это типы, которые хранят одно конкретное значение. Их четыре: целые числа, числа с плавающей точкой, булевы значения и символы.

#### 1. Целые числа (Integers)
Это числа без дробей. Бывают signed (со знаком `i` — могут быть отрицательными) и unsigned (без знака `u` — только положительные).

| Размер | Со знаком | Без знака |
| :--- | :--- | :--- |
| 8 бит | `i8` | `u8` (от 0 до 255) |
| 16 бит | `i16` | `u16` |
| 32 бита | `i32` | `u32` (дефолт) |
| 64 бита | `i64` | `u64` |
| 128 бит | `i128` | `u128` |
| По железу | `isize` | `usize` (зависит от разрядности твоего ведра) |

Фишка про переполнение (Overflow):**
Если у тебя u8 (макс 255) и ты запихнешь туда 256:
–   В debug режиме: прога вылетит с матами (panic).
–   В release режиме: Rust сделает «кольцо» (wrapping). 256 превратится в 0, 257 в 1. Это баг, так что не делай так.

#### 2. Числа с плавающей точкой (Floats)
Числа с запятой. Их всего два: f32 и f64. По дефолту юзается f64, потому что на современных процах оно работает с той же скоростью, что и f32, но гораздо точнее.

#### 3. Булев тип (Boolean)
Тут всё просто: true (тру) или false (пиздеж). Занимает 1 байт. Пишется как bool.

#### 4. Символьный тип (Character)
Пишется как char в одинарных кавычках: let c = 'z';.
Важно: в Расте char занимает 4 байта и это Unicode. То есть туда можно засунуть смайлик, иероглиф или любую дичь, и Rust не подавится.

---

### Составные типы (Лифчики для данных)
Они группируют несколько значений в одну кучу. Их два: кортежи (tuples) и массивы (arrays).

#### 1. Кортежи (Tuples)
Группируют данные разных типов. Длина фиксированная — объявил и всё, не растет.
let tup: (i32, f64, u8) = (500, 6.4, 1);
let (x, y, z) = tup; // Деструктуризация (разбор на части)
let five_hundred = tup.0; // Доступ через точку

Пустой кортеж () называется unit. Если функция ничего не возвращает, она на самом деле возвращает unit.

#### 2. Массивы (Arrays)
В массиве все элементы должны быть одного типа. Длина тоже жестко фиксирована.
let a = [1, 2, 3, 4, 5]; // Просто массив
let b: [i32; 5] = [1, 2, 3, 4, 5]; // Массив с типом и длиной
let c = [3; 5]; // Будет [3, 3, 3, 3, 3]

Массивы живут на стеке (это быстро). Если тебе нужен список, который растет или уменьшается, юзай Vector (но о нем позже).

Безопасность доступа:
Если ты попробуешь достать a[10], а там всего 5 элементов, Rust сразу уронит прогу (panic). В Си или Си++ ты бы просто прочитал какой-то мусор из памяти и поймал бы «сегфолт» через полчаса, а Rust обрывает эту херню на корню. Это и есть та самая «безопасность памяти».

=================================================================================
//Мой коммент: Бро, типов дохуя, но запомнить надо два главных правила:
1. Если не знаешь, какое целое число брать — бери `i32`.
2. Если хочешь залезть в массив по индексу, который ввел юзер — всегда проверяй ввод, иначе прога схлопнется.
