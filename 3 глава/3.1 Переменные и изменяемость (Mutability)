=========================================
Переменные и изменяемость (Mutability)
=========================================

Как мы уже вскользь упоминали, в Rust переменные по дефолту неизменяемые (immutable). Это один из тех мягких пинков, которыми Rust толкает тебя писать безопасный и быстрый код. Но если очень хочется, переменную можно сделать изменяемой. Давай разберемся, почему Rust топит за «заморозку» и когда стоит от неё отказаться.

Когда переменная неизменяемая, ты не можешь поменять значение после того, как "привязал" его к имени. Смотри пример. Создай проект `variables` через `cargo new variables` и в `src/main.rs` вбей вот это (код не скомпилится):

```rust
fn main() {
    let x = 5;
    println!("Значение x: {x}");
    x = 6; // Пытаемся переобуться
    println!("Значение x: {x}");
}
```

Запускаешь `cargo run` и получаешь леща от компилятора:
`error[E0384]: cannot assign twice to immutable variable x`

Компилятор как бы говорит: «Слышь, ты сказал, что `x` — это 5, а теперь пытаешься втереть мне 6. Определись уже!»

Это не значит, что ты плохой программист. Это значит, что Rust страхует твою задницу. Если одна часть кода думает, что значение никогда не изменится, а другая его внезапно меняет, жди багов, которые ты будешь ловить до седых яиц. Rust гарантирует: если сказал «не изменится» — значит, железно.

Чтобы разрешить изменения, добавь `mut`:

```rust
fn main() {
    let mut x = 5;
    println!("Значение x: {x}");
    x = 6;
    println!("Значение x: {x}");
}
```
Теперь всё четко. Использовать `mut` или нет — решать тебе, но старайся делать переменные изменяемыми только там, где это реально нужно.

### Константы

Константы похожи на неизменяемые переменные, но они еще более жесткие:
1.  Никаких mut. Константы не просто неизменяемые по дефолту — они такие всегда.
2.  Объявляются через `const`, а не `let`.
3.  Тип данных обязателен. Если у `let` Rust может сам догадаться, что это число, то у `const` ты обязан прописать тип (например, `u32`).
4.  Их можно объявлять где угодно, даже вне функций (глобально).
5.  Значение константы должно быть известно еще до запуска** программы. Ты не можешь присвоить константе результат работы функции, которая вычисляется во время работы.

Пример:
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
По канону имена констант пишутся КАПСОМ с подчеркиваниями.

### Затенение (Shadowing)

Помнишь, в игре-угадайке мы объявляли переменную с тем же именем? Это называется затенение. Вторая переменная как бы перекрывает собой первую.

fn main() {
    let x = 5;
    let x = x + 1; // Затенили первый x, теперь x = 6
    {
        let x = x * 2; // Затенили во внутреннем блоке, x = 12
        println!("x во внутреннем блоке: {x}");
    }
    println!("x в основном блоке: {x}"); // Здесь x всё еще 6
}


В чем прикол и отличие от `mut`?
–   Если ты случайно попробуешь перезаписать значение без слова let, компилятор даст по рукам.
–   Мы можем сменить тип данных, сохранив имя. Например, когда у нас был ввод текста, а мы хотим получить число:

let spaces = "   ";       // Это строка
let spaces = spaces.len(); // А это уже число!


Если бы мы юзали let mut spaces, нам бы прилетела ошибка, потому что нельзя менять тип переменной на лету. А через затенение — легко. Нам не нужно плодить переменные типа spaces_str и spaces_num, мы просто юзаем одно классное имя.
