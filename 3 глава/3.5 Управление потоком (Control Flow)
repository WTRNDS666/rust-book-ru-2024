=========================================
3.5 Управление потоком (Control Flow)
=========================================

Возможность выполнять код в зависимости от условия или крутить его в цикле — это база любого языка. В Rust для этого есть `if` и циклы (`loop`, `while`, `for`).

### Выражения if

`if` позволяет разветвлять код: «Если условие соблюдено — делай это, если нет — забей».

```rust
fn main() {
    let number = 3;

    if number < 5 {
        println!("Условие истинно");
    } else {
        println!("Условие ложно");
    }
}
```

Важный нюанс: Условие обязано быть строго `bool` (логическим). В JS или Си можно написать `if (number)`, и всё, что не ноль, будет правдой. В Rust такой фокус не прокатит — компилятор даст по рукам. Пиши четко: `if number != 0`.

#### Тройничок из if в let
Так как `if` — это выражение, его результат можно сразу присвоить переменной:
```rust
let condition = true;
let number = if condition { 5 } else { 6 };
```
Но помни: типы в обеих ветках должны совпадать. Нельзя в `if` вернуть число, а в `else` — строку. Rust должен знать тип переменной в момент компиляции, а не ловить сюрпризы в процессе работы.

---

========================
Циклы: крутим-вертим
========================

В Rust три вида циклов. Давай по порядку.

#### 1. Бесконечный `loop`
Он будет крутить код вечно, пока ты его не пристрелишь через `break`.
```rust
loop {
    println!("Снова!");
    break; // Ладно, хватит
}
```
Фишка:** Из loop можно возвращать значение. Типа "крути, пока не найдешь нужный ответ, и выплюни его":
let result = loop { counter += 1; if counter == 10 { break counter * 2; } };

Метки циклов: Если у тебя цикл в цикле, ты можешь пометить их именами (начинаются с одинарной кавычки), чтобы break знал, из какого именно круга ада ему валить:
'outer: loop { loop { break 'outer; } }

#### 2. Условный while
Классика: пока условие правдиво — работаем. Как только стало ложно — выходим.
while number != 0 {
    number -= 1;
}


#### 3. Красавчик for
Это самый чёткий и безопасный способ перебирать коллекции (массивы). 
Вместо того чтобы вручную следить за индексом через while (где легко ошибиться и выйти за границы памяти), юзай for:

let a = [10, 20, 30, 40, 50];
for element in a {
    println!("Значение: {element}");
}

Это и быстрее (компилятор оптимизирует проверки), и безопаснее. Чтобы просто посчитать от 1 до 3, юзай диапазоны: for number in 1..4.
