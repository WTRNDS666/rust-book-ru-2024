===============================
Глава 2. Игра «Угадай число»
===============================

Давай сразу в бой. В этой главе мы напишем классику — игру, где комп загадывает число от 1 до 100, а ты пытаешься его угадать. Попутно разберем `let`, `match`, методы, внешние библиотеки и прочую дичь.

====================
Настройка проекта
====================

Прыгай в свою папку `projects` и создавай новый проект через Cargo:

```bash
$ cargo new guessing_game
$ cd guessing_game
```
=====================
Обработка догадки
=====================

Для начала научим программу слушать, че ты там вводишь с клавиатуры. Сотри всё из `src/main.rs` и впиши вот это:

```rust
use std::io; // Подключаем библиотеку ввода-вывода

fn main() {
    println!("Угадай число!");
    println!("Вводи свою догадку:");

    // Создаем переменную для хранения ввода
    let mut guess = String::new();

    io::stdin()
        .read_line(&mut guess) // Читаем строку из консоли
        .expect("Не удалось прочитать строку"); // Если всё пошло по пизде

    println!("Твоя догадка: {guess}");
}
```

**Разбор полетов:**
*   `use std::io;` — по дефолту Rust вкидывает в твою прогу только самый минимум («prelude»). Ввод-вывод в этот минимум не входит, так что подключаем руками.
*   `let mut guess = String::new();` — тут жара. В Rust переменные по дефолту **неизменяемые** (immutable). Если хочешь, чтобы в переменную можно было что-то дописывать, надо добавить `mut`. `String::new()` создает пустую строку.
*   `::new` — это «ассоциированная функция». В других языках это называют статическим методом.
*   `&mut guess` — знак `&` значит, что это **ссылка**. Ты не отдаешь данные функции насовсем, а просто даешь «подержать». Ссылки тоже по дефолту неизменяемые, поэтому пишем `&mut`.
*   `.expect(...)` — в Rust функции часто возвращают тип `Result`. Это такая коробка, в которой либо успех (`Ok`), либо ошибка (`Err`). Если ты не обработаешь ошибку, Rust будет ныть. `expect` — самый простой способ: если там ошибка, прога просто упадет с твоим сообщением.

=============================
Генерируем секретное число
=============================

Rust из коробки не умеет в рандом. Для этого нам нужна внешняя либа (crate) под названием `rand`.

Открывай **Cargo.toml** и добавь зависимость:

```toml
[dependencies]
rand = "0.8.5"
```

Теперь Cargo сам скачает `rand` и всё, от чего она зависит. После этого обновляем наш код в `main.rs`:

```rust
use std::io;
use rand::Rng; // Добавляем трейт для работы с рандомом

fn main() {
    println!("Угадай число!");

    // Генерим число от 1 до 100 включительно
    let secret_number = rand::thread_rng().gen_range(1..=100);

    // println!("Секретное число: {secret_number}"); // Раскомментируй для читов

    loop { // Зацикливаем игру
        println!("Вводи свою догадку:");

        let mut guess = String::new();

        io::stdin()
            .read_line(&mut guess)
            .expect("Ошибка чтения");

        // Превращаем строку в число. Если ввели не число — просим еще раз
        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("Твоя догадка: {guess}");

        // Сравниваем
        match guess.cmp(&secret_number) {
            std::cmp::Ordering::Less => println!("Маловато!"),
            std::cmp::Ordering::Greater => println!("Многовато!"),
            std::cmp::Ordering::Equal => {
                println!("Красава, угадал!");
                break; // Выходим из цикла
            }
        }
    }
}
```

=============================
Главные фишки этого куска:
=============================

1.  **Shadowing (Затенение):** Заметил, что у нас две переменные `guess`? Сначала это была строка, а потом мы объявили `let guess: u32`. Rust позволяет «затенять» старые переменные новыми. Это удобно, когда надо быстро поменять тип данных и не придумывать имена типа `guess_str`.
2.  **Match:** Это как `switch` на стероидах. Мы проверяем результат сравнения (`cmp` возвращает `Less`, `Greater` или `Equal`) и выполняем нужный кусок кода.
3.  **Обработка ошибок через Match:** Когда мы парсим строку в число (`parse()`), мы используем `match`. Если всё `Ok`, берем число. Если `Err`, пишем `continue` — это перекидывает нас на следующую итерацию цикла, игнорируя кривой ввод (например, если ты ввел "хуй" вместо числа).

=========
Итог
=========

Ты только что написал полноценную прогу на Rust!
*   Ты узнал, что такое `cargo build` и как добавлять либы.
*   Понял, что ссылки и переменные по дефолту «заморожены» (`immutable`).
*   Увидел мощь `match`.

Теперь ты готов к Главе 3, где мы будем разбирать более глубокие технические дебри. Красавчик!
